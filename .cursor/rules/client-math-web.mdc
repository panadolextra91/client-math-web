---
alwaysApply: true
---
# Client-Side Development Guide - Math Learning Game

## Overview
This guide provides instructions for building the frontend UI using Next.js that connects to the Math Learning Game API server.

## Prerequisites
- Node.js LTS (>= 18)
- npm or yarn
- Next.js 14+ (App Router recommended)
- Basic knowledge of React, TypeScript, and API integration

## 1. Project Setup

### Initialize Next.js Project
```bash
npx create-next-app@latest math-game-client --typescript --tailwind --app
cd math-game-client
```

### Install Additional Dependencies
```bash
npm install axios
# or
npm install fetch (built-in, no install needed)
```

### Environment Variables
Create `.env.local`:
```env
NEXT_PUBLIC_API_URL=http://localhost:3000/api
NEXT_PUBLIC_ADMIN_API_KEY=your-admin-key-if-needed
```

## 2. Project Structure

```
math-game-client/
├── app/
│   ├── layout.tsx
│   ├── page.tsx (home/landing)
│   ├── game/
│   │   └── page.tsx (game interface)
│   ├── leaderboard/
│   │   └── page.tsx
│   ├── stats/
│   │   └── [playerName]/
│   │       └── page.tsx
│   └── api/ (optional: API routes for server-side calls)
├── components/
│   ├── Game/
│   │   ├── QuestionCard.tsx
│   │   ├── AnswerInput.tsx
│   │   ├── ScoreDisplay.tsx
│   │   └── Timer.tsx
│   ├── Leaderboard/
│   │   ├── LeaderboardTable.tsx
│   │   └── LeaderboardFilters.tsx
│   ├── Stats/
│   │   └── PlayerStats.tsx
│   └── Common/
│       ├── Button.tsx
│       ├── Input.tsx
│       └── LoadingSpinner.tsx
├── lib/
│   ├── api.ts (API client functions)
│   └── types.ts (TypeScript types matching API)
└── hooks/
    ├── useGameSession.ts
    ├── useLeaderboard.ts
    └── usePlayerStats.ts
```

## 3. API Client Setup

### Create API Client (`lib/api.ts`)

```typescript
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';

interface ApiResponse<T> {
  data?: T;
  error?: {
    code: string;
    message: string;
    requestId?: string;
    details?: any;
  };
}

async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<ApiResponse<T>> {
  try {
    const response = await fetch(`${API_URL}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return {
        error: data.error || {
          code: 'UNKNOWN_ERROR',
          message: 'An error occurred',
        },
      };
    }

    return { data };
  } catch (error) {
    return {
      error: {
        code: 'NETWORK_ERROR',
        message: error instanceof Error ? error.message : 'Network error',
      },
    };
  }
}

// Session API
export const sessionApi = {
  create: async (playerName: string, mode?: string, difficulty?: string) => {
    return apiRequest<{
      sessionId: number;
      playerName: string;
      startedAt: string;
    }>('/sessions', {
      method: 'POST',
      body: JSON.stringify({ playerName, mode, difficulty }),
    });
  },

  end: async (sessionId: number) => {
    return apiRequest<{
      sessionId: number;
      finishedAt: string;
      summary: any;
    }>(`/sessions/${sessionId}/end`, {
      method: 'PATCH',
    });
  },

  getSummary: async (sessionId: number) => {
    return apiRequest<any>(`/sessions/${sessionId}/summary`);
  },
};

// Question API
export const questionApi = {
  generate: async (sessionId: number, mode: string, difficulty: string) => {
    return apiRequest<{
      questionId: string;
      mode: string;
      difficulty: string;
      type: string;
      questionText: string;
      payload: any;
      maxTimeMs?: number;
    }>('/questions/generate', {
      method: 'POST',
      body: JSON.stringify({ sessionId, mode, difficulty }),
    });
  },
};

// Answer API
export const answerApi = {
  submit: async (
    sessionId: number,
    questionId: string | undefined,
    mode: string,
    difficulty: string,
    questionText: string,
    userAnswer: string,
    elapsedMs: number,
    correctAnswer?: string
  ) => {
    return apiRequest<{
      isCorrect: boolean;
      correctAnswer: string;
      scoreDelta: number;
      totalScore: number;
      stats: {
        totalQuestions: number;
        totalCorrect: number;
        totalWrong: number;
        accuracy: number;
        avgTimeMs: number;
      };
    }>('/answers/submit', {
      method: 'POST',
      body: JSON.stringify({
        sessionId,
        questionId,
        mode,
        difficulty,
        questionText,
        userAnswer,
        elapsedMs,
        correctAnswer,
      }),
    });
  },
};

// Leaderboard API
export const leaderboardApi = {
  get: async (params: {
    scope?: 'all' | 'weekly' | 'daily';
    limit?: number;
    page?: number;
    offset?: number;
  } = {}) => {
    const queryParams = new URLSearchParams();
    if (params.scope) queryParams.set('scope', params.scope);
    if (params.limit) queryParams.set('limit', params.limit.toString());
    if (params.page) queryParams.set('page', params.page.toString());
    if (params.offset) queryParams.set('offset', params.offset.toString());

    return apiRequest<{
      scope: string;
      updatedAt: string;
      entries: Array<{
        rank: number;
        playerName: string;
        totalScore: number;
        totalQuestions: number;
        accuracy: number;
        avgTimeMs: number | null;
      }>;
      pagination: {
        limit: number;
        offset: number;
        page: number | null;
        total: number;
        hasMore: boolean;
      };
    }>(`/leaderboard?${queryParams.toString()}`);
  },
};

// Player Stats API
export const playerApi = {
  getStats: async (playerName: string) => {
    return apiRequest<{
      playerName: string;
      totalSessions: number;
      totalQuestions: number;
      totalCorrect: number;
      totalWrong: number;
      accuracy: number;
      avgTimeMs: number | null;
      totalScore: number;
      bestScore: number;
      byDifficulty: Array<{
        level: string;
        totalQuestions: number;
        accuracy: number;
        avgTimeMs: number | null;
      }>;
    }>(`/players/${encodeURIComponent(playerName)}/stats`);
  },

  getMetrics: async (playerName: string) => {
    return apiRequest<{
      playerName: string;
      totalSessions: number;
      totalQuestions: number;
      totalCorrect: number;
      totalWrong: number;
      accuracy: number;
      averageResponseTime: number | null;
      totalScore: number;
      bestScore: number;
      byDifficulty: Array<{
        level: string;
        totalQuestions: number;
        accuracy: number;
        avgTimeMs: number | null;
      }>;
      timestamp: string;
    }>(`/players/${encodeURIComponent(playerName)}/metrics`);
  },
};

// Analytics API (optional - for admin)
export const analyticsApi = {
  getOverview: async (level?: string) => {
    const url = level ? `/analytics/overview?level=${level}` : '/analytics/overview';
    return apiRequest<any>(url);
  },
};

// Metrics API (admin only)
export const metricsApi = {
  get: async (adminApiKey?: string) => {
    const headers: HeadersInit = {};
    if (adminApiKey) {
      headers['X-Admin-API-Key'] = adminApiKey;
    }
    return apiRequest<any>('/metrics', { headers });
  },
};
```

## 4. TypeScript Types (`lib/types.ts`)

```typescript
export type GameMode = 'arithmetic' | 'equation';
export type Difficulty = 'easy' | 'medium' | 'hard';

export interface Session {
  sessionId: number;
  playerName: string;
  mode: GameMode | null;
  difficulty: Difficulty | null;
  startedAt: string;
  finishedAt?: string;
}

export interface Question {
  questionId: string;
  mode: GameMode;
  difficulty: Difficulty;
  type: GameMode;
  questionText: string;
  payload: {
    operands?: number[];
    operators?: string[];
    result?: number;
    answer?: string;
    // For equations
    coefficient?: number;
    constant?: number;
    solution?: number;
  };
  maxTimeMs?: number;
}

export interface AnswerResult {
  isCorrect: boolean;
  correctAnswer: string;
  scoreDelta: number;
  totalScore: number;
  stats: {
    totalQuestions: number;
    totalCorrect: number;
    totalWrong: number;
    accuracy: number;
    avgTimeMs: number;
  };
}

export interface LeaderboardEntry {
  rank: number;
  playerName: string;
  totalScore: number;
  totalQuestions: number;
  accuracy: number;
  avgTimeMs: number | null;
}
```

## 5. Custom Hooks

### Game Session Hook (`hooks/useGameSession.ts`)

```typescript
import { useState, useCallback } from 'react';
import { sessionApi, questionApi, answerApi } from '@/lib/api';
import type { GameMode, Difficulty, Question, AnswerResult } from '@/lib/types';

export function useGameSession() {
  const [sessionId, setSessionId] = useState<number | null>(null);
  const [currentQuestion, setCurrentQuestion] = useState<Question | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const startSession = useCallback(
    async (playerName: string, mode?: GameMode, difficulty?: Difficulty) => {
      setIsLoading(true);
      setError(null);
      const result = await sessionApi.create(playerName, mode, difficulty);
      if (result.error) {
        setError(result.error.message);
        setIsLoading(false);
        return false;
      }
      if (result.data) {
        setSessionId(result.data.sessionId);
        setIsLoading(false);
        return true;
      }
      return false;
    },
    []
  );

  const generateQuestion = useCallback(
    async (mode: GameMode, difficulty: Difficulty) => {
      if (!sessionId) return null;
      setIsLoading(true);
      setError(null);
      const result = await questionApi.generate(sessionId, mode, difficulty);
      if (result.error) {
        setError(result.error.message);
        setIsLoading(false);
        return null;
      }
      if (result.data) {
        setCurrentQuestion(result.data);
        setIsLoading(false);
        return result.data;
      }
      return null;
    },
    [sessionId]
  );

  const submitAnswer = useCallback(
    async (
      userAnswer: string,
      elapsedMs: number
    ): Promise<AnswerResult | null> => {
      if (!sessionId || !currentQuestion) return null;
      setIsLoading(true);
      setError(null);
      const result = await answerApi.submit(
        sessionId,
        currentQuestion.questionId,
        currentQuestion.mode,
        currentQuestion.difficulty,
        currentQuestion.questionText,
        userAnswer,
        elapsedMs
      );
      if (result.error) {
        setError(result.error.message);
        setIsLoading(false);
        return null;
      }
      if (result.data) {
        setIsLoading(false);
        return result.data;
      }
      return null;
    },
    [sessionId, currentQuestion]
  );

  const endSession = useCallback(async () => {
    if (!sessionId) return null;
    setIsLoading(true);
    const result = await sessionApi.end(sessionId);
    setIsLoading(false);
    return result.data || null;
  }, [sessionId]);

  return {
    sessionId,
    currentQuestion,
    isLoading,
    error,
    startSession,
    generateQuestion,
    submitAnswer,
    endSession,
  };
}
```

## 6. Key UI Components

### Game Page Example (`app/game/page.tsx`)

```typescript
'use client';

import { useState, useEffect, useRef } from 'react';
import { useGameSession } from '@/hooks/useGameSession';
import { useRouter, useSearchParams } from 'next/navigation';
import type { GameMode, Difficulty } from '@/lib/types';

export default function GamePage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const playerName = searchParams.get('player') || '';
  const mode = (searchParams.get('mode') as GameMode) || 'arithmetic';
  const difficulty = (searchParams.get('difficulty') as Difficulty) || 'easy';

  const {
    sessionId,
    currentQuestion,
    isLoading,
    error,
    startSession,
    generateQuestion,
    submitAnswer,
    endSession,
  } = useGameSession();

  const [answer, setAnswer] = useState('');
  const [score, setScore] = useState(0);
  const [timeElapsed, setTimeElapsed] = useState(0);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const startTimeRef = useRef<number>(0);

  // Initialize session
  useEffect(() => {
    if (playerName && !sessionId) {
      startSession(playerName, mode, difficulty);
    }
  }, [playerName, mode, difficulty, sessionId, startSession]);

  // Generate first question
  useEffect(() => {
    if (sessionId && !currentQuestion) {
      generateQuestion(mode, difficulty);
    }
  }, [sessionId, currentQuestion, mode, difficulty, generateQuestion]);

  // Start timer when question loads
  useEffect(() => {
    if (currentQuestion) {
      startTimeRef.current = Date.now();
      timerRef.current = setInterval(() => {
        setTimeElapsed(Date.now() - startTimeRef.current);
      }, 100);
    }
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [currentQuestion]);

  const handleSubmit = async () => {
    if (!answer.trim()) return;
    const elapsedMs = Date.now() - startTimeRef.current;
    const result = await submitAnswer(answer, elapsedMs);
    if (result) {
      setScore(result.totalScore);
      // Show feedback
      setTimeout(() => {
        setAnswer('');
        setTimeElapsed(0);
        generateQuestion(mode, difficulty);
      }, 2000);
    }
  };

  const handleEndGame = async () => {
    await endSession();
    router.push(`/stats/${playerName}`);
  };

  if (error) {
    return <div className="error">Error: {error}</div>;
  }

  if (isLoading || !currentQuestion) {
    return <div>Loading...</div>;
  }

  return (
    <div className="game-container">
      <div className="score">Score: {score}</div>
      <div className="timer">Time: {(timeElapsed / 1000).toFixed(1)}s</div>
      <div className="question">{currentQuestion.questionText}</div>
      <input
        type="text"
        value={answer}
        onChange={(e) => setAnswer(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}
        autoFocus
      />
      <button onClick={handleSubmit}>Submit</button>
      <button onClick={handleEndGame}>End Game</button>
    </div>
  );
}
```

### Leaderboard Component Example

```typescript
'use client';

import { useState, useEffect } from 'react';
import { leaderboardApi } from '@/lib/api';

export default function LeaderboardPage() {
  const [leaderboard, setLeaderboard] = useState<any>(null);
  const [scope, setScope] = useState<'all' | 'weekly' | 'daily'>('all');
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadLeaderboard();
  }, [scope, page]);

  const loadLeaderboard = async () => {
    setLoading(true);
    const result = await leaderboardApi.get({ scope, limit: 20, page });
    if (result.data) {
      setLeaderboard(result.data);
    }
    setLoading(false);
  };

  if (loading) return <div>Loading...</div>;
  if (!leaderboard) return <div>Error loading leaderboard</div>;

  return (
    <div>
      <div className="filters">
        <button onClick={() => setScope('all')}>All Time</button>
        <button onClick={() => setScope('weekly')}>Weekly</button>
        <button onClick={() => setScope('daily')}>Daily</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>Player</th>
            <th>Score</th>
            <th>Questions</th>
            <th>Accuracy</th>
            <th>Avg Time</th>
          </tr>
        </thead>
        <tbody>
          {leaderboard.entries.map((entry: any) => (
            <tr key={entry.rank}>
              <td>{entry.rank}</td>
              <td>{entry.playerName}</td>
              <td>{entry.totalScore}</td>
              <td>{entry.totalQuestions}</td>
              <td>{(entry.accuracy * 100).toFixed(1)}%</td>
              <td>{entry.avgTimeMs ? `${(entry.avgTimeMs / 1000).toFixed(1)}s` : 'N/A'}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <div className="pagination">
        <button
          disabled={page === 1}
          onClick={() => setPage(page - 1)}
        >
          Previous
        </button>
        <span>Page {page}</span>
        <button
          disabled={!leaderboard.pagination.hasMore}
          onClick={() => setPage(page + 1)}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

## 7. Error Handling

Always handle API errors gracefully:

```typescript
const result = await sessionApi.create(playerName);
if (result.error) {
  switch (result.error.code) {
    case 'VALIDATION_ERROR':
      // Show validation error message
      break;
    case 'NOT_FOUND':
      // Show not found message
      break;
    case 'UNAUTHORIZED':
      // Handle authentication error
      break;
    default:
      // Show generic error
  }
}
```

## 8. Important Notes

1. **Player Name Sanitization**: The server automatically sanitizes player names, but you should also validate on the client:
   - Trim whitespace
   - Limit to 64 characters
   - Only allow alphanumeric, spaces, hyphens, underscores

2. **Request ID Tracking**: The server returns `X-Request-ID` header. Log this for debugging:
   ```typescript
   const response = await fetch(url);
   const requestId = response.headers.get('X-Request-ID');
   console.log('Request ID:', requestId);
   ```

3. **CORS**: Ensure your frontend origin is set in server's `FRONTEND_ORIGIN` environment variable.

4. **Error Format**: All errors follow this format:
   ```json
   {
     "error": {
       "code": "ERROR_CODE",
       "message": "Human readable message",
       "requestId": "uuid",
       "details": {}
     }
   }
   ```

5. **Leaderboard Caching**: Leaderboard results are cached for 60 seconds. New answers automatically invalidate the cache.

6. **Session Cleanup**: Inactive sessions (>30 minutes) are automatically closed by the server.

## 9. Recommended UI/UX Features

- **Timer Display**: Show countdown or elapsed time for each question
- **Score Animation**: Animate score changes when answers are submitted
- **Feedback Messages**: Show "Correct!" or "Incorrect!" with the correct answer
- **Progress Indicators**: Show question number, accuracy percentage
- **Difficulty Selection**: Allow players to choose difficulty before starting
- **Game Mode Selection**: Toggle between arithmetic and equation modes
- **Responsive Design**: Ensure mobile-friendly layout
- **Loading States**: Show spinners during API calls
- **Error Toasts**: Display error messages in a user-friendly way

## 10. Testing

Test your integration with the server:
1. Start the server: `npm run dev` (in server directory)
2. Start Next.js: `npm run dev` (in client directory)
3. Test all flows: create session, generate questions, submit answers, view leaderboard

## 11. Production Deployment

- Update `NEXT_PUBLIC_API_URL` to your production server URL
- Ensure CORS is configured on the server for your production domain
- Consider using environment-specific configs for dev/staging/prod

## Support

For API documentation:
- Interactive docs: `http://localhost:3000/api/docs`
- OpenAPI JSON: `http://localhost:3000/api/docs.json`

For questions about the API, refer to the server's README.md file.

